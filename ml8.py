# -*- coding: utf-8 -*-
"""ML8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qNjVbHql0fnSsok3nS9TmQMi-Wo5jEur
"""

# Linear Regression From Scratch (No external file required)

import numpy as np
from sklearn.datasets import fetch_california_housing
from sklearn.model_selection import train_test_split

# --------------------------------------------------
# 1. Load Dataset (Regression dataset)
# --------------------------------------------------
data = fetch_california_housing()
X = data.data
y = data.target

# Normalize features
X = (X - X.mean(axis=0)) / X.std(axis=0)

# Add bias term (x0 = 1)
X = np.c_[np.ones(X.shape[0]), X]

# Train-Test Split
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# --------------------------------------------------
# 2. Cost Function (Mean Squared Error)
# --------------------------------------------------
def compute_cost(X, y, weights):
    m = len(y)
    predictions = X @ weights
    cost = (1/(2*m)) * np.sum((predictions - y)**2)
    return cost

# --------------------------------------------------
# 3. Gradient Descent Training
# --------------------------------------------------
def train_linear_regression(X, y, lr=0.01, iterations=1000):
    m, n = X.shape
    weights = np.zeros(n)

    for i in range(iterations):
        predictions = X @ weights
        gradient = (1/m) * (X.T @ (predictions - y))
        weights -= lr * gradient

        if i % 100 == 0:
            print(f"Iteration {i} | Cost: {compute_cost(X, y, weights):.4f}")

    return weights

# Train model
weights = train_linear_regression(X_train, y_train)

# --------------------------------------------------
# 4. Prediction Function
# --------------------------------------------------
def predict(X, weights):
    return X @ weights

y_pred = predict(X_test, weights)

# --------------------------------------------------
# 5. Model Evaluation (R² Score)
# --------------------------------------------------
ss_total = np.sum((y_test - np.mean(y_test))**2)
ss_residual = np.sum((y_test - y_pred)**2)
r2_score = 1 - (ss_residual / ss_total)

print("\nR² Score:", round(r2_score, 4))

# --------------------------------------------------
# 6. Display Some Predictions
# --------------------------------------------------
print("\nSample Predictions vs Actual:")
for i in range(5):
    print(f"Predicted: {y_pred[i]:.3f}  |  Actual: {y_test[i]:.3f}")