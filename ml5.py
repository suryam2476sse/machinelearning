# -*- coding: utf-8 -*-
"""ml5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16Q7FzAMD0QzvXqengi9R40M44DxttbDD
"""

# ==========================================================
# K-Nearest Neighbours (KNN) Implementation from Scratch
# Auto-load Iris dataset (no CSV required)
# ==========================================================

import math
import random
from sklearn.datasets import load_iris

# ----------------------------------------------------------
# 1. Load Iris Dataset Automatically
# ----------------------------------------------------------
def load_dataset():
    iris = load_iris()
    data = iris.data
    labels = iris.target

    dataset = []
    for i in range(len(data)):
        row = list(data[i]) + [labels[i]]
        dataset.append(row)
    return dataset

# ----------------------------------------------------------
# 2. Split Dataset into Train & Test
# ----------------------------------------------------------
def train_test_split(dataset, test_ratio=0.3):
    train_size = int(len(dataset) * (1 - test_ratio))
    random.shuffle(dataset)
    return dataset[:train_size], dataset[train_size:]

# ----------------------------------------------------------
# 3. Normalize Dataset (Min-Max Scaling)
# ----------------------------------------------------------
def minmax(dataset):
    minmax_vals = []
    for i in range(len(dataset[0]) - 1):
        col_values = [row[i] for row in dataset]
        min_val = min(col_values)
        max_val = max(col_values)
        minmax_vals.append((min_val, max_val))
    return minmax_vals

def normalize_dataset(dataset, minmax_vals):
    for row in dataset:
        for i in range(len(row) - 1):
            min_val, max_val = minmax_vals[i]
            row[i] = (row[i] - min_val) / (max_val - min_val)

# ----------------------------------------------------------
# 4. Euclidean Distance
# ----------------------------------------------------------
def euclidean_distance(row1, row2):
    distance = 0.0
    for i in range(len(row1) - 1):
        distance += (row1[i] - row2[i]) ** 2
    return math.sqrt(distance)

# ----------------------------------------------------------
# 5. Find K Nearest Neighbours
# ----------------------------------------------------------
def get_neighbors(train, test_row, k):
    distances = []
    for train_row in train:
        dist = euclidean_distance(test_row, train_row)
        distances.append((train_row, dist))
    distances.sort(key=lambda x: x[1])
    neighbors = [distances[i][0] for i in range(k)]
    return neighbors

# ----------------------------------------------------------
# 6. Predict Class (Majority Voting)
# ----------------------------------------------------------
def predict_classification(train, test_row, k):
    neighbors = get_neighbors(train, test_row, k)
    output_values = [row[-1] for row in neighbors]
    prediction = max(set(output_values), key=output_values.count)
    return prediction

# ----------------------------------------------------------
# 7. Accuracy Calculation
# ----------------------------------------------------------
def accuracy_metric(actual, predicted):
    correct = 0
    for i in range(len(actual)):
        if actual[i] == predicted[i]:
            correct += 1
    return correct / float(len(actual)) * 100.0

# ----------------------------------------------------------
# 8. Main Execution
# ----------------------------------------------------------
def main():
    dataset = load_dataset()

    # Normalize data
    minmax_vals = minmax(dataset)
    normalize_dataset(dataset, minmax_vals)

    # Split dataset
    train, test = train_test_split(dataset, test_ratio=0.3)

    # Choose K
    k = 5

    predictions = []
    actual = [row[-1] for row in test]

    for row in test:
        prediction = predict_classification(train, row, k)
        predictions.append(prediction)

    accuracy = accuracy_metric(actual, predictions)

    print("\nPredictions:", predictions)
    print("Actual:", actual)
    print("\nAccuracy: %.2f%%" % accuracy)

# Run program
if __name__ == "__main__":
    main()